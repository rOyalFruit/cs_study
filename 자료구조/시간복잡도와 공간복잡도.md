## 1. 시간복잡도(Time Complexity)

시간복잡도는 알고리즘이 실행되는 데 걸리는 시간을 입력 크기와의 관계로 나타낸 것이다. 주로 빅오(Big-O) 표기법으로 표현하며, 입력이 커질수록 실행 시간이 어떻게 변하는지 파악하는 데 사용한다.

- **O(빅오)**: 가장 오래 걸리는 상황(최악)
- **Ω(빅오메가)**: 가장 빨리 끝나는 상황(최선)
- **Θ(빅세타)**: 모든 입력에 대한 평균적인 시간(평균)

### 주요 시간복잡도 예시와 Java 코드
![](https://velog.velcdn.com/images/ekdeon/post/b41b77e9-057c-42bc-90ae-ad3340de5ed6/image.jpg)

| 복잡도     | 설명                  | 예시 코드(Java)                                      |
|------------|----------------------|------------------------------------------------------|
| O(1)       | 상수 시간             | `arr[index];`                                        |
| O(log n)   | 로그 시간             | 이진 탐색                                            |
| O(n)       | 선형 시간             | 배열 전체 합 구하기                                   |
| O(n log n) | 선형 로그 시간        | 병합 정렬, 퀵 정렬                                   |
| O(n²)      | 이차 시간(다항 시간)   | 이중 for문, 선택 정렬                                |
| O(2^n)     | 지수 시간             | 부분집합 생성(재귀)                                  |
| O(n!)      | 팩토리얼 시간         | 순열 생성(재귀)                                      |

O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2^n) < O(n!)

### 예시
입력 크기 n의 모든 입력에 대한 알고리즘에 필요한 시간이 10n²+n인 코드의 시간복잡도: O(n²)
```java
for (int i = 0; i < 10; i++) {
    for (int j = 0; j < n; j++) {
        for (int k = 0; k < n; k++) {
            System.out.println(k);
        }
    }
}

for (int i = 0; i < n; i++) {
    System.out.println(i);
}
```

### 복잡도 계산 시 주의사항
- **상수항과 낮은 차수는 무시**: O(2n + 5) → O(n)
- **최고차항만 고려**: O(n² + n) → O(n²)
- **중첩 반복문은 곱셈**: 바깥 n, 안쪽 m → O(n*m)
- **재귀는 점화식 또는 마스터 정리 활용**
- **실제 실행 시간은 하드웨어, 언어, 구현에 따라 다를 수 있으므로, 복잡도는 이론적 척도임을 기억**

---


## 2. 공간복잡도(Space Complexity)

공간복잡도는 알고리즘이 문제를 해결하는 데 사용하는 메모리의 양을 입력 크기와의 관계로 나타낸 것이다. 입력 데이터 외에 추가로 필요한 임시 공간(배열, 변수 등)을 포함한다.

- **Trade-off**: 시간 복잡도와 공간 복잡도는 종종 trade-off 관계에 있다. 시간을 절약하기 위해 더 많은 메모리를 사용하거나, 메모리를 절약하기위해 더 많은 시간을 소비하는 것이다.

---

## 3. 연결리스트 vs 배열 시간복잡도 비교

| 연산 | 연결리스트 시간복잡도 | 배열 시간복잡도 | 주의사항 |
|---------------------|----------------------|----------------------|--------------------------------------------------------------------------|
| **접근(인덱스)** | O(n) | O(1) | 배열은 임의 접근 가능, 연결리스트는 순차 접근 필요 |
| **삽입(처음)** | O(1) | O(n) | 배열은 모든 요소 이동 필요, 연결리스트는 헤드 조정만 |
| **삽입(끝)** | O(n)* | O(1)** | *연결리스트는 테일 포인터 없을 경우 끝까지 탐색 필요, **배열 공간 남아있을 경우 |
| **삽입(중간)** | O(n) | O(n) | 연결리스트는 위치 탐색 O(n) + 삽입 O(1), 배열은 요소 이동 필요 |
| **삭제(처음)** | O(1) | O(n) | 배열은 첫 요소 제거 후 모든 요소 이동 |
| **삭제(끝)** | O(n)* | O(1) | *연결리스트는 테일 포인터 없을 경우 끝까지 탐색 필요 |
| **삭제(중간)** | O(n) | O(n) | 연결리스트 위치 탐색 O(n) + 삭제 O(1), 배열은 요소 이동 필요 |
| **탐색** | O(n) | O(n)/O(log n)** | **정렬된 배열의 경우 이진 탐색 가능 |
| **결합** | O(1) | O(n) | 연결리스트는 포인터 조정만, 배열은 새 배열 생성 후 복사 필요 |
| **메모리 사용량** | 높음 (포인터 저장) | 낮음 | 연결리스트는 노드당 추가 메모리 필요 (Java 기준 24바이트/노드) |




